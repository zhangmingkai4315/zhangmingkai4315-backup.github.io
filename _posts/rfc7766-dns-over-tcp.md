---
layout: post
title: RFC 7766 DNS over TCP
date: 2019-04-01T11:32:41+00:00
author: mingkai
permalink: /2019/04/rfc7766
categories:
  - dns
  - rfc
---

本文档是在原有RFC5966的基础上进行的扩展，增加了一些相关研究内容和协议开发及实施过程中所积累的经验总结。

当前TCP在DNS协议中的实施已经变得越来越多，比如下面几个方面：
  - DNSSEC
  - DNS解析防伪造，防范反射和放大攻击
  - RRL速率限制
  - DNS隐私保护比如DNS-over-TLS

RFC1123更新了相关描述:**所有通用目的的DNS实施必须同时支持UDP和TCP两个协议，一个DNS解析器或者服务器在发送非区传输查询的时候必须首先发送UDP查询**。

但是该描述应当**适当放宽**：如果解析器已经打开了一个到DNS服务器的查询连接，应当重用该连接，TCP查询应当作为一个有效的传输选择而不仅仅当作是重试的选择。


#### 连接处理

HTTP协议中支持TCP连接持久化，并且允许通过任何一方发送的connection close信号关闭连接操作。RFC1035中描述服务器应当将所有的连接作为一个持久化连接，特别是查询SOA的连接，但是并为描述清楚其他的非SOA查询中如何处理，特别是也没有实施任何信号机制关闭超时或者Reset连接。

当前并没有任何协议去定义DNS软件如何去关闭连接，或者设置超时时间，但是通常来说，对于一个非SOA和AXFR的查询，一般客户端发送查询，接受响应结果后直接关闭此次连接。

服务器实施过程则相对比较复杂, 通常设置较长固定的空闲时间作为超时 以及少量的TCP连接数量，并提供一些TCP连接管理的参数。但是这种方式存在的问题是：

1. 较长的超时时间，导致在负载压力大的时候资源消耗过大
2. 故意的打开许多连接，且保持不关闭状态，将更容易的实施DOS攻击
3. 允许一定数量的DNS客户端，所有的都尝试并发持久化连接，也将导致DOS攻击的问题


#### 推荐实施措施

##### 连接复用

假如不实施复用的话，每次查询将增加一次额外的RTT 用于建立连接操作，但是客户端在复用连接的时候需要注意MessageID不能被复用，否则可能在服务器响应的信息中被服务器重新排序后返回，无法追踪。


##### 查询Pipeline

为了提升查询的性能，DNS客户端应该pipeline多个查询到服务器，客户端不应该等待任何一个响应接收到后再次发送，而是直接发送到服务器端无需等待。服务器端也需要处理接收到的pipeline查询并返回给客户端，可按照无顺序方式返回给客户端。


##### 并发连接

任何客户端和服务器之间的交互都推荐
- 仅仅开启一个连接去查询域名，
- 一个独立的连接用于区域传输请求（如果需要）
- 一个独立的连接处理TCP协议之上的比如TLS交互（如果需要）。

但是为了提升一些区传输的效率，服务器可能需要开启多个并发的连接去满足大量区数据传输的目的。

服务器可能需要增加客户端并发查询的最大数量，但是需要注意的是很多IP可能属于NAT转换的，导致其后面的机器将同时面临共享的最大连接数量。


##### 空闲时间

DNS客户端应该使用最小的空闲时间到任何的DNS服务器，并且应该关闭空闲的会话连接，除非使用的是edns-tcp-keepalive算法来实现的信号管理超时。
服务器应用的空闲周期时间应该按照秒来设置，但是在资源允许的情况下，可以动态的延长空闲超时时间， 或者在负载压力过大的情况下可以使用0超时时间的设置，缓解资源使用。
DNS消息传递的时候可能在不同的分段中传输，服务器应当在接收到完整的消息的时候重置其空闲超时时间，而不是仅仅接收到一个分段的时候（防止遭受slow-read-attack）


##### 关闭连接

服务器可以根据设置的本地空闲超时策略来主动关闭连接，或者基于安全的原因主动关闭，甚至是在系统服务重启或实效时候关闭。客户端应该重试任何没有受到响应的查询，本文档没有给出任何重试的实现机制。
如果服务器发现客户端主动关闭了连接，则应该停止发送任何尚未响应给客户端数据，当然，服务器可以缓存这些响应用于下次的查询。

#### 重新排序

权威和递归服务器推荐以并行的方式去准备用户的响应数据并且以无顺序的方式响应给客户端，不管使用任何传输协议。任何的客户端和解析器也必须有能力的区分不同顺序下的响应数据。客户端可以基于MessageID来匹配在此TCP传输链路上的查询响应，如果响应包含查询字段，客户端必须匹配QName，QClass以及QType. 


#### TCP消息长度域

DNS客户端和服务器应当传递2字节的长度域，以及消息信息一起到TCP协议层，主要是为了提升效率，以及减少从TCP协议读取数据的问题。比如一些DNS服务器实施可能中断一个TCP会话如果读取的数据不包含任何协议的长度信息。

但是服务器不应由于没有读取有效的长度信息而直接关闭连接，应该采用超时机制去控制连接的关闭。


#### TCP快启动（Fast-Open）

根据RFC7413描述：TCP协议支持在SYN数据中直接携带数据，减少TCP连接建立的时间。TFO（TCP FastOpen）客户端在初始化一个SYN新的连接阶段请求服务器Cookie， 服务器返回cookie(SYN+ACK) 客户端保存cookie信息并在下次重新启动连接的时候使用。该cookie信息存储在tcp协议内核栈中，并且可以被持久化，一旦实效后可以自动转换为tcp握手协议。

使用IP任意播的DNS服务需要注意的是：
负载均衡下的服务器应该为查询相同服务器IP的相同的客户端使用相同的key来产生相同的cookie，从而保证不会出现负载均衡下的失效回退

DNS-Over-TLS需要注意不要由于TFO而导致其查询内容被泄漏


#### 安全顾虑

为了缓解使用TCP可能导致的DOS攻击，DNS服务器建议实施一些必要的连接管理措施比如重用已经存在的连接，使用队列控制请求实现公平对，保持连接状态等等，另外需要优化的一些还包含：

- TCP连接的总数量
- 针对一个IP或者子网设置的最大的TCP连接数量
- 空闲超时时间
- 每个连接中最大的DNS数据传输
- 最大的TCP连接持久时间等


递归服务器应该确保仅仅允许必要的连接客户端，使用ACL策略防止出现反射攻击的问题，限制未知IP对于资源的使用
